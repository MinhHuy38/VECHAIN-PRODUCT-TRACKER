import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { VeChainKit } from '@vechain/vechain-kit';
import './App.css'; // Import file CSS

// --- TH√îNG TIN H·ª¢P ƒê·ªíNG (C·∫¶N THAY TH·∫æ B·∫∞NG K·∫æT QU·∫¢ TRI·ªÇN KHAI TH·ª∞C T·∫æ) ---
const contractAddress = "0xAbCDeF1234567890aBcDef1234567890aBCdeF12"; // <== D√ÅN ƒê·ªäA CH·ªà TH·ª∞C T·∫æ V√ÄO ƒê√ÇY
const contractABI = [ /* ... D√°n to√†n b·ªô n·ªôi dung file ABI.json v√†o ƒë√¢y ... */ ]; // <== D√ÅN ABI TH·ª∞C T·∫æ V√ÄO ƒê√ÇY

function App() {
    // States ƒë·ªÉ qu·∫£n l√Ω k·∫øt n·ªëi v√† t∆∞∆°ng t√°c blockchain
    const [wallet, setWallet] = useState(null);
    const [contract, setContract] = useState(null);
    const [account, setAccount] = useState(null);

    // States cho c√°c form nh·∫≠p li·ªáu
    const [productId, setProductId] = useState('');
    const [productName, setProductName] = useState('');
    const [updateProductId, setUpdateProductId] = useState('');
    const [updateLocation, setUpdateLocation] = useState('');
    const [updateStatus, setUpdateStatus] = useState('');

    // States ƒë·ªÉ tra c·ª©u v√† hi·ªÉn th·ªã k·∫øt qu·∫£
    const [searchId, setSearchId] = useState('');
    const [productHistory, setProductHistory] = useState([]);
    const [productDetails, setProductDetails] = useState(null);
    
    // States ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i giao di·ªán
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState('');

    // Kh·ªüi t·∫°o VeChainKit khi component ƒë∆∞·ª£c t·∫£i
    useEffect(() => {
        const vechainKit = new VeChainKit({
            node: 'https://testnet.vechain.org',
            network: 'test',
        });
        setWallet(vechainKit);
    }, []);

    // H√†m k·∫øt n·ªëi v√≠
    const connectWallet = async () => {
        if (!wallet) return;
        try {
            const res = await wallet.connect();
            if (res.account) {
                setAccount(res.account);
                const ethersProvider = new ethers.providers.Web3Provider(wallet.thor);
                const ethersSigner = ethersProvider.getSigner(res.account);
                const contractInstance = new ethers.Contract(contractAddress, contractABI, ethersSigner);
                setContract(contractInstance);
                setMessage(`‚úÖ ƒê√£ k·∫øt n·ªëi v√≠: ${res.account.substring(0, 6)}...${res.account.substring(res.account.length - 4)}`);
            }
        } catch (error) {
            console.error(error);
            setMessage(" L·ªói k·∫øt n·ªëi v√≠. Vui l√≤ng th·ª≠ l·∫°i.");
        }
    };
    
    // H√†m x·ª≠ l√Ω vi·ªác t·∫°o s·∫£n ph·∫©m
    const handleCreateProduct = async (e) => {
        e.preventDefault();
        if (!contract || !productId || !productName) {
            setMessage("Vui l√≤ng k·∫øt n·ªëi v√≠ v√† ƒëi·ªÅn ƒë·ªß ID, T√™n s·∫£n ph·∫©m.");
            return;
        }
        setLoading(true);
        setMessage(`ƒêang g·ª≠i giao d·ªãch t·∫°o s·∫£n ph·∫©m ${productId}...`);
        try {
            const tx = await contract.createProduct(productId, productName, "initial_ipfs_hash_placeholder");
            setMessage(`‚è≥ Giao d·ªãch ƒë√£ ƒë∆∞·ª£c g·ª≠i, ƒëang ch·ªù x√°c nh·∫≠n... Hash: ${tx.hash.substring(0,10)}...`);
            await tx.wait(); // ƒê·ª£i giao d·ªãch ƒë∆∞·ª£c ƒë∆∞a v√†o kh·ªëi
            setMessage(`üéâ T·∫°o s·∫£n ph·∫©m ${productId} th√†nh c√¥ng!`);
        } catch (error) {
            console.error(error);
            setMessage(`‚ùå L·ªói t·∫°o s·∫£n ph·∫©m: ${error?.data?.message || error.message}`);
        }
        setLoading(false);
    };

    // H√†m x·ª≠ l√Ω vi·ªác c·∫≠p nh·∫≠t l·ªãch s·ª≠
    const handleAddHistory = async (e) => {
        e.preventDefault();
        if (!contract || !updateProductId || !updateLocation || !updateStatus) {
            setMessage("Vui l√≤ng ƒëi·ªÅn ƒë·ªß ID s·∫£n ph·∫©m v√† th√¥ng tin c·∫≠p nh·∫≠t.");
            return;
        }
        setLoading(true);
        setMessage(`ƒêang g·ª≠i giao d·ªãch c·∫≠p nh·∫≠t cho s·∫£n ph·∫©m ${updateProductId}...`);
        try {
            const tx = await contract.addHistory(updateProductId, updateLocation, updateStatus, "update_ipfs_hash_placeholder");
            setMessage(`‚è≥ Giao d·ªãch ƒë√£ ƒë∆∞·ª£c g·ª≠i, ƒëang ch·ªù x√°c nh·∫≠n... Hash: ${tx.hash.substring(0,10)}...`);
            await tx.wait();
            setMessage(`üéâ C·∫≠p nh·∫≠t l·ªãch s·ª≠ cho s·∫£n ph·∫©m ${updateProductId} th√†nh c√¥ng!`);
        } catch (error) {
            console.error(error);
            setMessage(`‚ùå L·ªói c·∫≠p nh·∫≠t: ${error?.data?.message || error.message}`);
        }
        setLoading(false);
    };
    
    // H√†m x·ª≠ l√Ω vi·ªác t√¨m ki·∫øm s·∫£n ph·∫©m
    const handleSearchProduct = async (e) => {
        e.preventDefault();
        if (!contract || !searchId) return;
        setLoading(true);
        setProductHistory([]);
        setProductDetails(null);
        setMessage(`ƒêang t√¨m ki·∫øm s·∫£n ph·∫©m ${searchId}...`);
        try {
            // S·ª≠ d·ª•ng provider ƒë·ªÉ g·ªçi h√†m view m√† kh√¥ng c·∫ßn signer
            const readOnlyContract = new ethers.Contract(contractAddress, contractABI, wallet.thor);
            const history = await readOnlyContract.getProductHistory(searchId);
            const details = await readOnlyContract.products(searchId);
            
            setProductDetails({ name: details.name, creator: details.creator });
            setProductHistory(history);
            setMessage(`‚úÖ ƒê√£ t√¨m th·∫•y ${history.length} b·∫£n ghi l·ªãch s·ª≠ cho s·∫£n ph·∫©m.`);
        } catch (error) {
            console.error(error);
            setMessage(`‚ùå L·ªói t√¨m ki·∫øm: S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i ho·∫∑c c√≥ l·ªói m·∫°ng.`);
        }
        setLoading(false);
    };

    return (
        <div className="container">
            <header className="header">
                <h1>·ª®ng d·ª•ng Truy xu·∫•t Ngu·ªìn g·ªëc "Product Tracker"</h1>
                <p>X√¢y d·ª±ng tr√™n n·ªÅn t·∫£ng Blockchain VeChain</p>
                {account ? (
                    <div className="wallet-info">K·∫øt n·ªëi: {account}</div>
                ) : (
                    <button onClick={connectWallet} className="connect-button">K·∫øt n·ªëi v√≠ VeWorld</button>
                )}
            </header>

            {message && <div className={`message ${message.includes('L·ªói') ? 'error' : ''}`}>{message}</div>}

            <div className="main-content">
                <div className="card">
                    <h2>Qu·∫£n tr·ªã (Y√™u c·∫ßu vai tr√≤)</h2>
                    <form onSubmit={handleCreateProduct}>
                        <h3>T·∫°o S·∫£n ph·∫©m m·ªõi</h3>
                        <input type="number" placeholder="ID S·∫£n ph·∫©m" value={productId} onChange={e => setProductId(e.target.value)} required />
                        <input type="text" placeholder="T√™n S·∫£n ph·∫©m" value={productName} onChange={e => setProductName(e.target.value)} required />
                        <button type="submit" disabled={loading || !account}>{loading ? 'ƒêang x·ª≠ l√Ω...' : 'T·∫°o S·∫£n ph·∫©m'}</button>
                    </form>
                    <hr />
                    <form onSubmit={handleAddHistory}>
                        <h3>C·∫≠p nh·∫≠t L·ªãch s·ª≠ S·∫£n ph·∫©m</h3>
                        <input type="number" placeholder="ID S·∫£n ph·∫©m c·∫ßn c·∫≠p nh·∫≠t" value={updateProductId} onChange={e => setUpdateProductId(e.target.value)} required />
                        <input type="text" placeholder="V·ªã tr√≠ hi·ªán t·∫°i" value={updateLocation} onChange={e => setUpdateLocation(e.target.value)} required />
                        <input type="text" placeholder="Tr·∫°ng th√°i" value={updateStatus} onChange={e => setUpdateStatus(e.target.value)} required />
                        <button type="submit" disabled={loading || !account}>{loading ? 'ƒêang x·ª≠ l√Ω...' : 'C·∫≠p nh·∫≠t L·ªãch s·ª≠'}</button>
                    </form>
                </div>

                <div className="card">
                    <h2>Tra c·ª©u C√¥ng khai</h2>
                    <form onSubmit={handleSearchProduct}>
                        <input type="number" placeholder="Nh·∫≠p ID S·∫£n ph·∫©m ƒë·ªÉ tra c·ª©u" value={searchId} onChange={e => setSearchId(e.target.value)} required />
                        <button type="submit" disabled={loading}>{loading ? 'ƒêang t√¨m...' : 'T√¨m ki·∫øm'}</button>
                    </form>
                    
                    {productDetails && (
                        <div className="results-container">
                            <h3>Th√¥ng tin S·∫£n ph·∫©m ID: {searchId}</h3>
                            <p><strong>T√™n s·∫£n ph·∫©m:</strong> {productDetails.name}</p>
                            <p><strong>Ng∆∞·ªùi t·∫°o:</strong> {productDetails.creator}</p>
                            <h4>L·ªãch s·ª≠ h√†nh tr√¨nh:</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Th·ªùi gian</th>
                                        <th>V·ªã tr√≠</th>
                                        <th>Tr·∫°ng th√°i</th>
                                        <th>Ng∆∞·ªùi c·∫≠p nh·∫≠t</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {productHistory.map((entry, index) => (
                                        <tr key={index}>
                                            <td>{new Date(entry.timestamp * 1000).toLocaleString('vi-VN')}</td>
                                            <td>{entry.location}</td>
                                            <td>{entry.status}</td>
                                            <td>{entry.updatedBy}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default App;
